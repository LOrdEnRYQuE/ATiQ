import { useIntegrations, Provider } from './store/integrations'
import { getWorkflowFiles, getWorkflowTemplate } from './templates/workflows'
import { generatePipelineConfig } from './ai-orchestrator'
import { detectDeploymentTarget } from './deployment-service'

export type PublishTarget = 'mobile' | 'web' | 'desktop'
export type PublishStatus = 'idle' | 'preparing' | 'creating_repo' | 'pushing' | 'triggering' | 'success' | 'error'

export interface PublishResult {
  status: PublishStatus
  message?: string
  error?: string
  repoUrl?: string
  workflowUrl?: string
  instructions?: string
}

export interface PublishConfig {
  target: PublishTarget
  projectName: string
  version?: string
  files: Record<string, string>
}

export class PublishService {
  private integrations = useIntegrations.getState()

  async publishToStores(config: PublishConfig): Promise<PublishResult> {
    try {
      // Step 1: Validate required integrations
      const validation = this.validateIntegrations(config.target)
      if (!validation.valid) {
        return {
          status: 'error',
          error: `Missing required integrations: ${validation.missing.join(', ')}`
        }
      }

      // Step 2: Prepare deployment files
      const deploymentFiles = await this.prepareDeploymentFiles(config)

      // Step 3: Create GitHub repository
      const repoResult = await this.createGitHubRepo(config)
      if (!repoResult.success) {
        return {
          status: 'error',
          error: repoResult.error
        }
      }

      // Step 4: Push code and workflows
      const pushResult = await this.pushToGitHub(repoResult.repoUrl!, deploymentFiles)
      if (!pushResult.success) {
        return {
          status: 'error',
          error: pushResult.error
        }
      }

      // Step 5: Trigger workflow
      const workflowResult = await this.triggerWorkflow(repoResult.repoUrl!, config.target)
      
      return {
        status: 'success',
        message: `Successfully published ${config.projectName} to deployment pipeline!`,
        repoUrl: repoResult.repoUrl,
        workflowUrl: workflowResult.workflowUrl,
        instructions: this.getInstructions(config.target, repoResult.repoUrl!)
      }

    } catch (error) {
      console.error('Publish error:', error)
      return {
        status: 'error',
        error: error instanceof Error ? error.message : 'Publish failed'
      }
    }
  }

  private validateIntegrations(target: PublishTarget): { valid: boolean; missing: Provider[] } {
    const integrations = useIntegrations.getState()
    const required: Provider[] = ['github'] // Always need GitHub

    switch (target) {
      case 'mobile':
        required.push('expo')
        break
      case 'web':
        required.push('vercel')
        break
      case 'desktop':
        // Desktop only needs GitHub for builds
        break
    }

    const missing = required.filter(provider => !integrations.hasKey(provider))
    
    return {
      valid: missing.length === 0,
      missing
    }
  }

  private async prepareDeploymentFiles(config: PublishConfig): Promise<Record<string, string>> {
    const files = { ...config.files }
    
    // Get workflow templates
    const workflowFiles = getWorkflowFiles(config.target)
    
    // Add workflow files to the project
    workflowFiles.forEach(({ path, content }) => {
      files[path] = content
    })

    // Use AI to generate enhanced configurations if needed
    try {
      const aiConfig = await generatePipelineConfig(config.target)
      // Parse AI response and add generated files
      // This would integrate with your XML stream parser
    } catch (error) {
      console.warn('AI config generation failed, using templates:', error)
    }

    return files
  }

  private async createGitHubRepo(config: PublishConfig): Promise<{ success: boolean; repoUrl?: string; error?: string }> {
    const githubToken = this.integrations.getKey('github')
    if (!githubToken) {
      return { success: false, error: 'GitHub token not found' }
    }

    const repoName = config.projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-')
    
    try {
      const response = await fetch('https://api.github.com/user/repos', {
        method: 'POST',
        headers: {
          'Authorization': `token ${githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: repoName,
          description: `Generated by Vibe Coding - ${config.target} application`,
          private: true,
          auto_init: false
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        return { 
          success: false, 
          error: errorData.message || `GitHub API error: ${response.status}` 
        }
      }

      const repoData = await response.json()
      return { 
        success: true, 
        repoUrl: repoData.clone_url 
      }

    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to create GitHub repo' 
      }
    }
  }

  private async pushToGitHub(repoUrl: string, files: Record<string, string>): Promise<{ success: boolean; error?: string }> {
    // This would use GitHub API to create files
    // For now, return success as this would be implemented with proper Git operations
    
    try {
      const githubToken = this.integrations.getKey('github')
      if (!githubToken) {
        return { success: false, error: 'GitHub token not found' }
      }

      // Create files via GitHub API
      for (const [filePath, content] of Object.entries(files)) {
        const response = await fetch(`https://api.github.com/repos/${this.getRepoFromUrl(repoUrl)}/contents/${filePath}`, {
          method: 'PUT',
          headers: {
            'Authorization': `token ${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: `Add ${filePath}`,
            content: Buffer.from(content).toString('base64')
          })
        })

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}))
          console.warn(`Failed to create ${filePath}:`, errorData.message)
        }
      }

      return { success: true }

    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to push to GitHub' 
      }
    }
  }

  private async triggerWorkflow(repoUrl: string, target: PublishTarget): Promise<{ success: boolean; workflowUrl?: string; error?: string }> {
    const githubToken = this.integrations.getKey('github')
    if (!githubToken) {
      return { success: false, error: 'GitHub token not found' }
    }

    try {
      // Trigger the workflow by creating a dispatch event
      const response = await fetch(`https://api.github.com/repos/${this.getRepoFromUrl(repoUrl)}/actions/workflows/deploy-${target}.yml/dispatches`, {
        method: 'POST',
        headers: {
          'Authorization': `token ${githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          ref: 'main'
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        return { 
          success: false, 
          error: errorData.message || `Failed to trigger workflow: ${response.status}` 
        }
      }

      const workflowUrl = `https://github.com/${this.getRepoFromUrl(repoUrl)}/actions`
      
      return { 
        success: true, 
        workflowUrl 
      }

    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to trigger workflow' 
      }
    }
  }

  private getRepoFromUrl(repoUrl: string): string {
    // Extract owner/repo from GitHub URL
    const match = repoUrl.match(/github\.com\/(.+?)(?:\.git)?$/)
    return match ? match[1] : ''
  }

  private getInstructions(target: PublishTarget, repoUrl: string): string {
    switch (target) {
      case 'mobile':
        return `Your mobile app is now building! üì±\n\n` +
               `1. Watch the build progress at GitHub Actions\n` +
               `2. You'll receive an email from Expo when ready for TestFlight\n` +
               `3. Review and submit to App Store/Google Play from Expo dashboard`
               
      case 'web':
        return `Your web app is deploying! üåê\n\n` +
               `1. Watch the deployment at GitHub Actions\n` +
               `2. Your app will be live on Vercel shortly\n` +
               `3. Check your Vercel dashboard for the deployment URL`
               
      case 'desktop':
        return `Your desktop app is building! üíª\n\n` +
               `1. Watch the build progress at GitHub Actions\n` +
               `2. Download builds for Windows, Mac, and Linux from the Releases page\n` +
               `3. Distribute to your users or upload to app stores`
               
      default:
        return 'Check GitHub Actions for build progress.'
    }
  }

  // Quick publish method for one-click deployment
  async quickPublish(files: Record<string, string>, projectName: string): Promise<PublishResult> {
    // Auto-detect target from files
    const detectedTarget = detectDeploymentTarget(files)
    
    let target: PublishTarget
    switch (detectedTarget) {
      case 'expo':
        target = 'mobile'
        break
      case 'vercel':
        target = 'web'
        break
      case 'github':
        target = 'desktop'
        break
      default:
        target = 'web' // Default to web
    }

    return this.publishToStores({
      target,
      projectName,
      files,
      version: '1.0.0'
    })
  }
}

// Singleton instance
export const publishService = new PublishService()

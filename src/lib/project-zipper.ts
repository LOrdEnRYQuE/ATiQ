/**
 * Project ZIP Export - Download projects as ZIP files
 * Allows users to "eject" from the platform and take their code elsewhere
 */

import JSZip from 'jszip'
import { saveAs } from 'file-saver'

export interface ZipExportOptions {
  projectName?: string
  includeMetadata?: boolean
  includeReadme?: boolean
  includeGitignore?: boolean
}

export async function downloadProjectAsZip(
  files: Record<string, string>, 
  options: ZipExportOptions = {}
): Promise<void> {
  const {
    projectName = 'vibe-project',
    includeMetadata = true,
    includeReadme = true,
    includeGitignore = true
  } = options

  const zip = new JSZip()

  // Add all project files
  Object.entries(files).forEach(([path, content]) => {
    // Ensure path doesn't start with '/'
    const cleanPath = path.startsWith('/') ? path.slice(1) : path
    zip.file(cleanPath, content)
  })

  // Add README.md if requested
  if (includeReadme && !files['README.md']) {
    const readmeContent = generateReadme(projectName, files)
    zip.file('README.md', readmeContent)
  }

  // Add .gitignore if requested
  if (includeGitignore && !files['.gitignore']) {
    const gitignoreContent = generateGitignore()
    zip.file('.gitignore', gitignoreContent)
  }

  // Add project metadata if requested
  if (includeMetadata) {
    const metadata = {
      projectName,
      exportedAt: new Date().toISOString(),
      fileCount: Object.keys(files).length,
      totalSize: Object.values(files).reduce((sum, content) => sum + content.length, 0),
      platform: 'ATiQ Vibe Coding',
      version: '1.0.0'
    }
    zip.file('vibe-project.json', JSON.stringify(metadata, null, 2))
  }

  try {
    // Generate the blob
    const content = await zip.generateAsync({ 
      type: 'blob',
      compression: 'DEFLATE',
      compressionOptions: { level: 6 }
    })

    // Trigger download
    saveAs(content, `${projectName}.zip`)
    
    console.log(`‚úÖ Project exported: ${Object.keys(files).length} files`)
  } catch (error) {
    console.error('‚ùå Failed to export project:', error)
    throw new Error('Failed to generate ZIP file')
  }
}

/**
 * Generate a README.md for the exported project
 */
function generateReadme(projectName: string, files: Record<string, string>): string {
  const fileTypes = analyzeProjectTypes(files)
  const hasPackageJson = files['package.json']
  let packageInfo: { scripts?: Record<string, string>; [key: string]: unknown } = {}

  try {
    if (hasPackageJson) {
      packageInfo = JSON.parse(files['package.json'])
    }
  } catch {
    console.warn('Could not parse package.json')
  }

  return `# ${projectName}

This project was created with [ATiQ Vibe Coding](https://vibe.new) - an AI-powered development platform.

## Project Structure

${fileTypes.map(type => `- ${type.count} ${type.name} files`).join('\n')}

${hasPackageJson ? `
## Getting Started

\`\`\`bash
# Install dependencies
${packageInfo.scripts?.install ? packageInfo.scripts.install : 'npm install'}

# Start development server
${packageInfo.scripts?.dev ? packageInfo.scripts.dev : 'npm run dev'}
\`\`\`

### Available Scripts

${Object.entries(packageInfo.scripts || {}).map(([script, command]) => 
  `- \`npm run ${script}\`: ${command}`
).join('\n')}
` : ''}

## About ATiQ Vibe Coding

ATiQ Vibe Coding is an AI-powered development environment that helps you build applications faster with intelligent code generation, real-time error detection, and automatic debugging.

**Features:**
- ü§ñ AI-powered code generation
- üõ°Ô∏è Automatic error detection and repair
- üîÑ Real-time preview with hot reload
- üíæ Auto-save and project persistence
- üì¶ One-click project export

## Next Steps

- Continue developing your project in your favorite IDE
- Deploy to your preferred hosting platform
- Share your project with the team

---

*Generated by ATiQ Vibe Coding on ${new Date().toLocaleDateString()}*`
}

/**
 * Generate a .gitignore file
 */
function generateGitignore(): string {
  return `# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Production builds
dist/
build/
.next/
out/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
logs/
*.log

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# Temporary folders
tmp/
temp/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# ATiQ Vibe Coding specific
.vibe-coding/
webcontainer/`
}

/**
 * Analyze project file types
 */
function analyzeProjectTypes(files: Record<string, string>): Array<{ name: string; count: number }> {
  const types: Record<string, number> = {}

  Object.keys(files).forEach(filePath => {
    const extension = filePath.split('.').pop()?.toLowerCase()
    
    if (extension) {
      const typeMap: Record<string, string> = {
        'js': 'JavaScript',
        'jsx': 'React JSX',
        'ts': 'TypeScript', 
        'tsx': 'React TSX',
        'vue': 'Vue',
        'html': 'HTML',
        'css': 'CSS',
        'scss': 'SCSS',
        'sass': 'Sass',
        'json': 'JSON',
        'md': 'Markdown',
        'png': 'Image',
        'jpg': 'Image',
        'jpeg': 'Image',
        'svg': 'SVG',
        'gif': 'Image'
      }

      const typeName = typeMap[extension] || extension.toUpperCase()
      types[typeName] = (types[typeName] || 0) + 1
    }
  })

  return Object.entries(types)
    .map(([name, count]) => ({ name, count }))
    .sort((a, b) => b.count - a.count)
}

/**
 * Check if project can be exported (size limits)
 */
export function canExportProject(files: Record<string, string>): {
  canExport: boolean
  reason?: string
  estimatedSize?: number
} {
  const totalSize = Object.values(files).reduce((sum, content) => sum + content.length, 0)
  const fileCount = Object.keys(files).length

  // Check file count limit
  if (fileCount > 1000) {
    return {
      canExport: false,
      reason: 'Too many files (max 1000)',
      estimatedSize: totalSize
    }
  }

  // Check size limit (50MB)
  if (totalSize > 50 * 1024 * 1024) {
    return {
      canExport: false,
      reason: 'Project too large (max 50MB)',
      estimatedSize: totalSize
    }
  }

  return {
    canExport: true,
    estimatedSize: totalSize
  }
}

/**
 * Get export statistics
 */
export function getExportStats(files: Record<string, string>) {
  const fileCount = Object.keys(files).length
  const totalSize = Object.values(files).reduce((sum, content) => sum + content.length, 0)
  const fileTypes = analyzeProjectTypes(files)

  return {
    fileCount,
    totalSize,
    totalSizeMB: (totalSize / (1024 * 1024)).toFixed(2),
    fileTypes,
    largestFile: Object.entries(files).reduce((largest, [path, content]) => 
      content.length > largest.size ? { path, size: content.length } : largest, 
      { path: '', size: 0 }
    )
  }
}

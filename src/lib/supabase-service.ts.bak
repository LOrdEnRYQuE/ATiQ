import { supabase, supabaseAdmin } from './supabase'
import type { Database, Tables, TablesInsert, TablesUpdate } from '@/types/database'

// Generic CRUD operations
export class SupabaseService<T extends keyof Database['public']['Tables']> {
  private tableName: T

  constructor(tableName: T) {
    this.tableName = tableName
  }

  // Get all records
  async getAll(select = '*') {
    const { data, error } = await supabase
      .from(this.tableName)
      .select(select)
    
    if (error) throw error
    return data as any[]
  }

  // Get by ID
  async getById(id: string, select = '*') {
    const { data, error } = await supabase
      .from(this.tableName)
      .select(select)
      .eq('id', id)
      .single()
    
    if (error) throw error
    return data as any
  }

  // Create new record
  async create(data: TablesInsert<T>) {
    const { data: result, error } = await supabase
      .from(this.tableName)
      .insert(data)
      .select()
      .single()
    
    if (error) throw error
    return result as Tables<T>['Row']
  }

  // Update record
  async update(id: string, data: TablesUpdate<T>) {
    const { data: result, error } = await supabase
      .from(this.tableName)
      .update(data)
      .eq('id', id)
      .select()
      .single()
    
    if (error) throw error
    return result as Tables<T>['Row']
  }

  // Delete record
  async delete(id: string) {
    const { error } = await supabase
      .from(this.tableName)
      .delete()
      .eq('id', id)
    
    if (error) throw error
    return true
  }

  // Admin operations (bypass RLS)
  async adminGetAll(select = '*') {
    const { data, error } = await supabaseAdmin
      .from(this.tableName)
      .select(select)
    
    if (error) throw error
    return data as Tables<T>['Row'][]
  }

  async adminCreate(data: TablesInsert<T>) {
    const { data: result, error } = await supabaseAdmin
      .from(this.tableName)
      .insert(data)
      .select()
      .single()
    
    if (error) throw error
    return result as Tables<T>['Row']
  }
}

// Specific services
export const usersService = new SupabaseService('users')
export const projectsService = new SupabaseService('projects')
export const projectMembersService = new SupabaseService('project_members')
export const filesService = new SupabaseService('files')
export const chatMessagesService = new SupabaseService('chat_messages')
export const notificationsService = new SupabaseService('notifications')
export const usageAnalyticsService = new SupabaseService('usage_analytics')
export const apiKeysService = new SupabaseService('api_keys')
export const teamInvitationsService = new SupabaseService('team_invitations')

// Advanced query helpers
export class QueryBuilder<T extends keyof Database['public']['Tables']> {
  private query: any
  private tableName: T

  constructor(tableName: T) {
    this.tableName = tableName
    this.query = supabase.from(tableName)
  }

  select(columns: string) {
    this.query = this.query.select(columns)
    return this
  }

  where(column: keyof Tables<T>['Row'], operator: string, value: any) {
    this.query = this.query.eq(column as string, value)
    return this
  }

  whereIn(column: keyof Tables<T>['Row'], values: any[]) {
    this.query = this.query.in(column as string, values)
    return this
  }

  order(column: keyof Tables<T>['Row'], ascending = true) {
    this.query = this.query.order(column as string, { ascending })
    return this
  }

  limit(count: number) {
    this.query = this.query.limit(count)
    return this
  }

  range(from: number, to: number) {
    this.query = this.query.range(from, to)
    return this
  }

  async execute() {
    const { data, error } = await this.query
    if (error) throw error
    return data as Tables<T>['Row'][]
  }

  async single() {
    const { data, error } = await this.query.single()
    if (error) throw error
    return data as Tables<T>['Row']
  }
}

// Real-time subscriptions
export class RealtimeService {
  private subscriptions: Map<string, any> = new Map()

  subscribe<T extends keyof Database['public']['Tables']>(
    tableName: T,
    event: 'INSERT' | 'UPDATE' | 'DELETE' | '*',
    callback: (payload: any) => void,
    filter?: string
  ) {
    const subscriptionName = `${tableName}_${event}_${Date.now()}`
    
    let query = supabase
      .channel(subscriptionName)
      .on('postgres_changes', 
        { 
          event, 
          schema: 'public', 
          table: tableName as string,
          filter
        }, 
        callback
      )
      .subscribe()

    this.subscriptions.set(subscriptionName, query)
    return subscriptionName
  }

  unsubscribe(subscriptionName: string) {
    const subscription = this.subscriptions.get(subscriptionName)
    if (subscription) {
      supabase.removeChannel(subscription)
      this.subscriptions.delete(subscriptionName)
    }
  }

  unsubscribeAll() {
    this.subscriptions.forEach((subscription) => {
      supabase.removeChannel(subscription)
    })
    this.subscriptions.clear()
  }
}

export const realtimeService = new RealtimeService()

// File upload utilities
export class FileService {
  static async upload(file: File, path: string, bucket = 'uploads') {
    const { data, error } = await supabase.storage
      .from(bucket)
      .upload(path, file, {
        cacheControl: '3600',
        upsert: true
      })

    if (error) throw error
    return data
  }

  static async getPublicUrl(path: string, bucket = 'uploads') {
    const { data } = supabase.storage
      .from(bucket)
      .getPublicUrl(path)

    return data.publicUrl
  }

  static async delete(path: string, bucket = 'uploads') {
    const { error } = await supabase.storage
      .from(bucket)
      .remove([path])

    if (error) throw error
    return true
  }

  static async list(bucket = 'uploads', path = '') {
    const { data, error } = await supabase.storage
      .from(bucket)
      .list(path)

    if (error) throw error
    return data
  }
}

// Analytics tracking
export class AnalyticsService {
  static async track(
    eventType: string,
    eventData: Record<string, any> = {},
    userId?: string,
    projectId?: string
  ) {
    const { error } = await supabase
      .from('usage_analytics')
      .insert({
        user_id: userId || null,
        project_id: projectId || null,
        event_type: eventType,
        event_data: eventData,
        ip_address: null, // Will be set by server
        user_agent: typeof window !== 'undefined' ? window.navigator.userAgent : null
      })

    if (error) console.error('Analytics tracking error:', error)
  }

  static async trackPageView(page: string, userId?: string) {
    return this.track('page_view', { page }, userId)
  }

  static async trackProjectAction(
    action: string,
    projectId: string,
    userId?: string,
    data: Record<string, any> = {}
  ) {
    return this.track('project_action', { action, ...data }, userId, projectId)
  }

  static async trackAIUsage(
    tokensUsed: number,
    model: string,
    projectId: string,
    userId?: string
  ) {
    return this.track(
      'ai_usage',
      { tokens_used: tokensUsed, model },
      userId,
      projectId
    )
  }
}

// Notification service
export class NotificationService {
  static async create(
    userId: string,
    type: Database['public']['Enums']['notification_type'],
    title: string,
    message?: string,
    notificationData: Record<string, any> = {}
  ) {
    const { data, error } = await supabase
      .from('notifications')
      .insert({
        user_id: userId,
        type,
        title,
        message,
        data: notificationData,
        read: false
      })
      .select()
      .single()

    if (error) throw error
    return data
  }

  static async markAsRead(notificationId: string) {
    const { error } = await supabase
      .from('notifications')
      .update({ read: true })
      .eq('id', notificationId)

    if (error) throw error
    return true
  }

  static async markAllAsRead(userId: string) {
    const { error } = await supabase
      .from('notifications')
      .update({ read: true })
      .eq('user_id', userId)
      .eq('read', false)

    if (error) throw error
    return true
  }

  static async getUnreadCount(userId: string) {
    const { count, error } = await supabase
      .from('notifications')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .eq('read', false)

    if (error) throw error
    return count || 0
  }
}

// Team invitation service
export class TeamInvitationService {
  static async create(
    projectId: string,
    email: string,
    role: Database['public']['Enums']['user_role'],
    invitedBy: string
  ) {
    const token = crypto.randomUUID()
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days

    const { data, error } = await supabase
      .from('team_invitations')
      .insert({
        project_id: projectId,
        invited_email: email,
        invited_by: invitedBy,
        role,
        token,
        expires_at: expiresAt.toISOString()
      })
      .select()
      .single()

    if (error) throw error
    return data
  }

  static async accept(token: string, userId: string) {
    // Get invitation
    const { data: invitation, error: inviteError } = await supabase
      .from('team_invitations')
      .select('*')
      .eq('token', token)
      .single()

    if (inviteError) throw inviteError

    // Add user to project members
    const { error: memberError } = await supabase
      .from('project_members')
      .insert({
        project_id: invitation.project_id,
        user_id: userId,
        role: invitation.role,
        joined_at: new Date().toISOString()
      })

    if (memberError) throw memberError

    // Mark invitation as accepted
    const { error: updateError } = await supabase
      .from('team_invitations')
      .update({ accepted_at: new Date().toISOString() })
      .eq('token', token)

    if (updateError) throw updateError

    return true
  }

  static async getByProject(projectId: string) {
    const { data, error } = await supabase
      .from('team_invitations')
      .select(`
        *,
        users!invited_by(email, full_name)
      `)
      .eq('project_id', projectId)
      .is('accepted_at', null)

    if (error) throw error
    return data
  }
}
